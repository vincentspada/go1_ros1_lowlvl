#include <iostream>
#include <signal.h>
#include <ros/ros.h>
#include "geometry_msgs/Wrench.h"
#include <unitree_legged_msgs/LowCmd.h>
#include "unitree_legged_sdk/unitree_legged_sdk.h"
#include <unitree_legged_msgs/LowState.h>
using namespace UNITREE_LEGGED_SDK;
sig_atomic_t volatile g_request_shutdown = 0;
void sigIntHandler(int sig)
{
  g_request_shutdown = 1;
}
class LowCommunication
{
  public:
    LowCommunication()
    {
      ROS_INFO_STREAM("Starting low communication");
      lcmd_.head[0] = 0xFE;        
      lcmd_.head[1] = 0xEF;        
      lcmd_.levelFlag = LOWLEVEL;
      lcmd_.reserve = 0;    
      const auto queue_size = 100;
      lcmd_pub_ = nh_.advertise<unitree_legged_msgs::LowCmd>("low_cmd", queue_size);                       
      lcmd_sub_ = nh_.subscribe("cmd_torque", queue_size, &LowCommunication::lcmdTorqueCallback, this);    
      ros::Duration(1.0).sleep();
      start_motor();
      ROS_INFO_STREAM("low communication ready");
    }
    void shutdown()
    {
      stop_motors();
      ros::Duration(1.0).sleep();
      ROS_INFO_STREAM("Stopping and exiting..." );
      ros::shutdown();
      std::cout << "Exited." << std::endl;
    }
  private:
    ros::NodeHandle nh_;
    ros::Publisher lcmd_pub_;
    ros::Subscriber lcmd_sub_;
    unitree_legged_msgs::LowCmd lcmd_;
    unitree_legged_msgs::LowState lstate_;
    void lcmdTorqueCallback(geometry_msgs::Wrench msg)
    {
      std::vector<double> command{msg.torque.z};
      publishCommand(command);
    }
    void start_motor() //motors
    {
      lcmd_.motorCmd[0].mode = 0x0A;
      lcmd_pub_.publish(lcmd_);
      ROS_INFO_STREAM("Robot started");
    }
    void stop_motors()
    {
      for(int i=0; i<4; i++){
        lcmd_.motorCmd[i*3+0].tau = 0;
        lcmd_.motorCmd[i*3+1].tau = 0;     
        lcmd_.motorCmd[i*3+2].tau = 0;      
    }
      lcmd_pub_.publish(lcmd_);
      ROS_INFO_STREAM("Robot stopped");
    }
    void publishCommand(std::vector<double> command)
    {
      double v = clamp(command[0], -2.0, 2.0);
      lcmd_.motorCmd[0].tau = command[0];
      lcmd_pub_.publish(lcmd_);
    }
    double clamp(double n, double lower, double upper) {
      return std::max(lower, std::min(n, upper));
    }
};
auto main(int argc, char **argv) -> int
{
  ros::init(argc, argv, "low_communication", ros::init_options::NoSigintHandler);
  signal(SIGINT, sigIntHandler);
  LowCommunication comm;
  ros::Rate rate(100.0);
  while (!g_request_shutdown && ros::ok())
  {
    ros::spinOnce();
    rate.sleep();
  }
  comm.shutdown();
  return 0;
}
